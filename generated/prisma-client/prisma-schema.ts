// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateAttribute {
  count: Int!
}

type AggregateEmail {
  count: Int!
}

type AggregateFemale {
  count: Int!
}

type AggregateIdentifiers {
  count: Int!
}

type AggregateMale {
  count: Int!
}

type AggregatePhoneNumber {
  count: Int!
}

type AggregateTaxId {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Attribute {
  id: ID!
  attr_type: String!
  tax_id(where: TaxIdWhereInput, orderBy: TaxIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TaxId!]
  email(where: EmailWhereInput, orderBy: EmailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Email!]
  phone_number(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber!]
}

type AttributeConnection {
  pageInfo: PageInfo!
  edges: [AttributeEdge]!
  aggregate: AggregateAttribute!
}

input AttributeCreateInput {
  id: ID
  attr_type: String!
  tax_id: TaxIdCreateManyWithoutAttributeInput
  email: EmailCreateManyWithoutAttributeInput
  phone_number: PhoneNumberCreateManyWithoutAttributeInput
}

input AttributeCreateManyInput {
  create: [AttributeCreateInput!]
  connect: [AttributeWhereUniqueInput!]
}

input AttributeCreateManyWithoutEmailInput {
  create: [AttributeCreateWithoutEmailInput!]
  connect: [AttributeWhereUniqueInput!]
}

input AttributeCreateManyWithoutPhone_numberInput {
  create: [AttributeCreateWithoutPhone_numberInput!]
  connect: [AttributeWhereUniqueInput!]
}

input AttributeCreateManyWithoutTax_idInput {
  create: [AttributeCreateWithoutTax_idInput!]
  connect: [AttributeWhereUniqueInput!]
}

input AttributeCreateWithoutEmailInput {
  id: ID
  attr_type: String!
  tax_id: TaxIdCreateManyWithoutAttributeInput
  phone_number: PhoneNumberCreateManyWithoutAttributeInput
}

input AttributeCreateWithoutPhone_numberInput {
  id: ID
  attr_type: String!
  tax_id: TaxIdCreateManyWithoutAttributeInput
  email: EmailCreateManyWithoutAttributeInput
}

input AttributeCreateWithoutTax_idInput {
  id: ID
  attr_type: String!
  email: EmailCreateManyWithoutAttributeInput
  phone_number: PhoneNumberCreateManyWithoutAttributeInput
}

type AttributeEdge {
  node: Attribute!
  cursor: String!
}

enum AttributeOrderByInput {
  id_ASC
  id_DESC
  attr_type_ASC
  attr_type_DESC
}

type AttributePreviousValues {
  id: ID!
  attr_type: String!
}

input AttributeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  attr_type: String
  attr_type_not: String
  attr_type_in: [String!]
  attr_type_not_in: [String!]
  attr_type_lt: String
  attr_type_lte: String
  attr_type_gt: String
  attr_type_gte: String
  attr_type_contains: String
  attr_type_not_contains: String
  attr_type_starts_with: String
  attr_type_not_starts_with: String
  attr_type_ends_with: String
  attr_type_not_ends_with: String
  AND: [AttributeScalarWhereInput!]
  OR: [AttributeScalarWhereInput!]
  NOT: [AttributeScalarWhereInput!]
}

type AttributeSubscriptionPayload {
  mutation: MutationType!
  node: Attribute
  updatedFields: [String!]
  previousValues: AttributePreviousValues
}

input AttributeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttributeWhereInput
  AND: [AttributeSubscriptionWhereInput!]
  OR: [AttributeSubscriptionWhereInput!]
  NOT: [AttributeSubscriptionWhereInput!]
}

input AttributeUpdateDataInput {
  attr_type: String
  tax_id: TaxIdUpdateManyWithoutAttributeInput
  email: EmailUpdateManyWithoutAttributeInput
  phone_number: PhoneNumberUpdateManyWithoutAttributeInput
}

input AttributeUpdateInput {
  attr_type: String
  tax_id: TaxIdUpdateManyWithoutAttributeInput
  email: EmailUpdateManyWithoutAttributeInput
  phone_number: PhoneNumberUpdateManyWithoutAttributeInput
}

input AttributeUpdateManyDataInput {
  attr_type: String
}

input AttributeUpdateManyInput {
  create: [AttributeCreateInput!]
  update: [AttributeUpdateWithWhereUniqueNestedInput!]
  upsert: [AttributeUpsertWithWhereUniqueNestedInput!]
  delete: [AttributeWhereUniqueInput!]
  connect: [AttributeWhereUniqueInput!]
  set: [AttributeWhereUniqueInput!]
  disconnect: [AttributeWhereUniqueInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyMutationInput {
  attr_type: String
}

input AttributeUpdateManyWithoutEmailInput {
  create: [AttributeCreateWithoutEmailInput!]
  delete: [AttributeWhereUniqueInput!]
  connect: [AttributeWhereUniqueInput!]
  set: [AttributeWhereUniqueInput!]
  disconnect: [AttributeWhereUniqueInput!]
  update: [AttributeUpdateWithWhereUniqueWithoutEmailInput!]
  upsert: [AttributeUpsertWithWhereUniqueWithoutEmailInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyWithoutPhone_numberInput {
  create: [AttributeCreateWithoutPhone_numberInput!]
  delete: [AttributeWhereUniqueInput!]
  connect: [AttributeWhereUniqueInput!]
  set: [AttributeWhereUniqueInput!]
  disconnect: [AttributeWhereUniqueInput!]
  update: [AttributeUpdateWithWhereUniqueWithoutPhone_numberInput!]
  upsert: [AttributeUpsertWithWhereUniqueWithoutPhone_numberInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyWithoutTax_idInput {
  create: [AttributeCreateWithoutTax_idInput!]
  delete: [AttributeWhereUniqueInput!]
  connect: [AttributeWhereUniqueInput!]
  set: [AttributeWhereUniqueInput!]
  disconnect: [AttributeWhereUniqueInput!]
  update: [AttributeUpdateWithWhereUniqueWithoutTax_idInput!]
  upsert: [AttributeUpsertWithWhereUniqueWithoutTax_idInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput!
  data: AttributeUpdateManyDataInput!
}

input AttributeUpdateWithoutEmailDataInput {
  attr_type: String
  tax_id: TaxIdUpdateManyWithoutAttributeInput
  phone_number: PhoneNumberUpdateManyWithoutAttributeInput
}

input AttributeUpdateWithoutPhone_numberDataInput {
  attr_type: String
  tax_id: TaxIdUpdateManyWithoutAttributeInput
  email: EmailUpdateManyWithoutAttributeInput
}

input AttributeUpdateWithoutTax_idDataInput {
  attr_type: String
  email: EmailUpdateManyWithoutAttributeInput
  phone_number: PhoneNumberUpdateManyWithoutAttributeInput
}

input AttributeUpdateWithWhereUniqueNestedInput {
  where: AttributeWhereUniqueInput!
  data: AttributeUpdateDataInput!
}

input AttributeUpdateWithWhereUniqueWithoutEmailInput {
  where: AttributeWhereUniqueInput!
  data: AttributeUpdateWithoutEmailDataInput!
}

input AttributeUpdateWithWhereUniqueWithoutPhone_numberInput {
  where: AttributeWhereUniqueInput!
  data: AttributeUpdateWithoutPhone_numberDataInput!
}

input AttributeUpdateWithWhereUniqueWithoutTax_idInput {
  where: AttributeWhereUniqueInput!
  data: AttributeUpdateWithoutTax_idDataInput!
}

input AttributeUpsertWithWhereUniqueNestedInput {
  where: AttributeWhereUniqueInput!
  update: AttributeUpdateDataInput!
  create: AttributeCreateInput!
}

input AttributeUpsertWithWhereUniqueWithoutEmailInput {
  where: AttributeWhereUniqueInput!
  update: AttributeUpdateWithoutEmailDataInput!
  create: AttributeCreateWithoutEmailInput!
}

input AttributeUpsertWithWhereUniqueWithoutPhone_numberInput {
  where: AttributeWhereUniqueInput!
  update: AttributeUpdateWithoutPhone_numberDataInput!
  create: AttributeCreateWithoutPhone_numberInput!
}

input AttributeUpsertWithWhereUniqueWithoutTax_idInput {
  where: AttributeWhereUniqueInput!
  update: AttributeUpdateWithoutTax_idDataInput!
  create: AttributeCreateWithoutTax_idInput!
}

input AttributeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  attr_type: String
  attr_type_not: String
  attr_type_in: [String!]
  attr_type_not_in: [String!]
  attr_type_lt: String
  attr_type_lte: String
  attr_type_gt: String
  attr_type_gte: String
  attr_type_contains: String
  attr_type_not_contains: String
  attr_type_starts_with: String
  attr_type_not_starts_with: String
  attr_type_ends_with: String
  attr_type_not_ends_with: String
  tax_id_every: TaxIdWhereInput
  tax_id_some: TaxIdWhereInput
  tax_id_none: TaxIdWhereInput
  email_every: EmailWhereInput
  email_some: EmailWhereInput
  email_none: EmailWhereInput
  phone_number_every: PhoneNumberWhereInput
  phone_number_some: PhoneNumberWhereInput
  phone_number_none: PhoneNumberWhereInput
  AND: [AttributeWhereInput!]
  OR: [AttributeWhereInput!]
  NOT: [AttributeWhereInput!]
}

input AttributeWhereUniqueInput {
  id: ID
}

enum AuthLevel {
  ADMIN
  USER
  PROSPECT
  BLACKLISTED
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Email {
  id: ID!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  attribute(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type EmailConnection {
  pageInfo: PageInfo!
  edges: [EmailEdge]!
  aggregate: AggregateEmail!
}

input EmailCreateInput {
  id: ID
  value: String!
  owner: UserCreateOneInput!
  attribute: AttributeCreateManyWithoutEmailInput
}

input EmailCreateManyInput {
  create: [EmailCreateInput!]
  connect: [EmailWhereUniqueInput!]
}

input EmailCreateManyWithoutAttributeInput {
  create: [EmailCreateWithoutAttributeInput!]
  connect: [EmailWhereUniqueInput!]
}

input EmailCreateWithoutAttributeInput {
  id: ID
  value: String!
  owner: UserCreateOneInput!
}

type EmailEdge {
  node: Email!
  cursor: String!
}

enum EmailOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmailPreviousValues {
  id: ID!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EmailScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EmailScalarWhereInput!]
  OR: [EmailScalarWhereInput!]
  NOT: [EmailScalarWhereInput!]
}

type EmailSubscriptionPayload {
  mutation: MutationType!
  node: Email
  updatedFields: [String!]
  previousValues: EmailPreviousValues
}

input EmailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmailWhereInput
  AND: [EmailSubscriptionWhereInput!]
  OR: [EmailSubscriptionWhereInput!]
  NOT: [EmailSubscriptionWhereInput!]
}

input EmailUpdateDataInput {
  value: String
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyWithoutEmailInput
}

input EmailUpdateInput {
  value: String
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyWithoutEmailInput
}

input EmailUpdateManyDataInput {
  value: String
}

input EmailUpdateManyInput {
  create: [EmailCreateInput!]
  update: [EmailUpdateWithWhereUniqueNestedInput!]
  upsert: [EmailUpsertWithWhereUniqueNestedInput!]
  delete: [EmailWhereUniqueInput!]
  connect: [EmailWhereUniqueInput!]
  set: [EmailWhereUniqueInput!]
  disconnect: [EmailWhereUniqueInput!]
  deleteMany: [EmailScalarWhereInput!]
  updateMany: [EmailUpdateManyWithWhereNestedInput!]
}

input EmailUpdateManyMutationInput {
  value: String
}

input EmailUpdateManyWithoutAttributeInput {
  create: [EmailCreateWithoutAttributeInput!]
  delete: [EmailWhereUniqueInput!]
  connect: [EmailWhereUniqueInput!]
  set: [EmailWhereUniqueInput!]
  disconnect: [EmailWhereUniqueInput!]
  update: [EmailUpdateWithWhereUniqueWithoutAttributeInput!]
  upsert: [EmailUpsertWithWhereUniqueWithoutAttributeInput!]
  deleteMany: [EmailScalarWhereInput!]
  updateMany: [EmailUpdateManyWithWhereNestedInput!]
}

input EmailUpdateManyWithWhereNestedInput {
  where: EmailScalarWhereInput!
  data: EmailUpdateManyDataInput!
}

input EmailUpdateWithoutAttributeDataInput {
  value: String
  owner: UserUpdateOneRequiredInput
}

input EmailUpdateWithWhereUniqueNestedInput {
  where: EmailWhereUniqueInput!
  data: EmailUpdateDataInput!
}

input EmailUpdateWithWhereUniqueWithoutAttributeInput {
  where: EmailWhereUniqueInput!
  data: EmailUpdateWithoutAttributeDataInput!
}

input EmailUpsertWithWhereUniqueNestedInput {
  where: EmailWhereUniqueInput!
  update: EmailUpdateDataInput!
  create: EmailCreateInput!
}

input EmailUpsertWithWhereUniqueWithoutAttributeInput {
  where: EmailWhereUniqueInput!
  update: EmailUpdateWithoutAttributeDataInput!
  create: EmailCreateWithoutAttributeInput!
}

input EmailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  attribute_every: AttributeWhereInput
  attribute_some: AttributeWhereInput
  attribute_none: AttributeWhereInput
  AND: [EmailWhereInput!]
  OR: [EmailWhereInput!]
  NOT: [EmailWhereInput!]
}

input EmailWhereUniqueInput {
  id: ID
}

type Female {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  attribute(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type FemaleConnection {
  pageInfo: PageInfo!
  edges: [FemaleEdge]!
  aggregate: AggregateFemale!
}

input FemaleCreateInput {
  id: ID
  owner: UserCreateOneInput!
  attribute: AttributeCreateManyInput
}

type FemaleEdge {
  node: Female!
  cursor: String!
}

enum FemaleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FemalePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FemaleSubscriptionPayload {
  mutation: MutationType!
  node: Female
  updatedFields: [String!]
  previousValues: FemalePreviousValues
}

input FemaleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FemaleWhereInput
  AND: [FemaleSubscriptionWhereInput!]
  OR: [FemaleSubscriptionWhereInput!]
  NOT: [FemaleSubscriptionWhereInput!]
}

input FemaleUpdateInput {
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyInput
}

input FemaleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  attribute_every: AttributeWhereInput
  attribute_some: AttributeWhereInput
  attribute_none: AttributeWhereInput
  AND: [FemaleWhereInput!]
  OR: [FemaleWhereInput!]
  NOT: [FemaleWhereInput!]
}

input FemaleWhereUniqueInput {
  id: ID
}

enum Gender {
  M
  F
}

type Identifiers {
  id: ID!
  tax_id(where: TaxIdWhereInput, orderBy: TaxIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TaxId!]
  email(where: EmailWhereInput, orderBy: EmailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Email!]
  phone_number(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber!]
}

type IdentifiersConnection {
  pageInfo: PageInfo!
  edges: [IdentifiersEdge]!
  aggregate: AggregateIdentifiers!
}

input IdentifiersCreateInput {
  id: ID
  tax_id: TaxIdCreateManyInput
  email: EmailCreateManyInput
  phone_number: PhoneNumberCreateManyInput
}

input IdentifiersCreateOneInput {
  create: IdentifiersCreateInput
  connect: IdentifiersWhereUniqueInput
}

type IdentifiersEdge {
  node: Identifiers!
  cursor: String!
}

enum IdentifiersOrderByInput {
  id_ASC
  id_DESC
}

type IdentifiersPreviousValues {
  id: ID!
}

type IdentifiersSubscriptionPayload {
  mutation: MutationType!
  node: Identifiers
  updatedFields: [String!]
  previousValues: IdentifiersPreviousValues
}

input IdentifiersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IdentifiersWhereInput
  AND: [IdentifiersSubscriptionWhereInput!]
  OR: [IdentifiersSubscriptionWhereInput!]
  NOT: [IdentifiersSubscriptionWhereInput!]
}

input IdentifiersUpdateDataInput {
  tax_id: TaxIdUpdateManyInput
  email: EmailUpdateManyInput
  phone_number: PhoneNumberUpdateManyInput
}

input IdentifiersUpdateInput {
  tax_id: TaxIdUpdateManyInput
  email: EmailUpdateManyInput
  phone_number: PhoneNumberUpdateManyInput
}

input IdentifiersUpdateOneRequiredInput {
  create: IdentifiersCreateInput
  update: IdentifiersUpdateDataInput
  upsert: IdentifiersUpsertNestedInput
  connect: IdentifiersWhereUniqueInput
}

input IdentifiersUpsertNestedInput {
  update: IdentifiersUpdateDataInput!
  create: IdentifiersCreateInput!
}

input IdentifiersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tax_id_every: TaxIdWhereInput
  tax_id_some: TaxIdWhereInput
  tax_id_none: TaxIdWhereInput
  email_every: EmailWhereInput
  email_some: EmailWhereInput
  email_none: EmailWhereInput
  phone_number_every: PhoneNumberWhereInput
  phone_number_some: PhoneNumberWhereInput
  phone_number_none: PhoneNumberWhereInput
  AND: [IdentifiersWhereInput!]
  OR: [IdentifiersWhereInput!]
  NOT: [IdentifiersWhereInput!]
}

input IdentifiersWhereUniqueInput {
  id: ID
}

scalar Long

type Male {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  attribute(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type MaleConnection {
  pageInfo: PageInfo!
  edges: [MaleEdge]!
  aggregate: AggregateMale!
}

input MaleCreateInput {
  id: ID
  owner: UserCreateOneInput!
  attribute: AttributeCreateManyInput
}

type MaleEdge {
  node: Male!
  cursor: String!
}

enum MaleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MalePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MaleSubscriptionPayload {
  mutation: MutationType!
  node: Male
  updatedFields: [String!]
  previousValues: MalePreviousValues
}

input MaleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MaleWhereInput
  AND: [MaleSubscriptionWhereInput!]
  OR: [MaleSubscriptionWhereInput!]
  NOT: [MaleSubscriptionWhereInput!]
}

input MaleUpdateInput {
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyInput
}

input MaleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  attribute_every: AttributeWhereInput
  attribute_some: AttributeWhereInput
  attribute_none: AttributeWhereInput
  AND: [MaleWhereInput!]
  OR: [MaleWhereInput!]
  NOT: [MaleWhereInput!]
}

input MaleWhereUniqueInput {
  id: ID
}

type Mutation {
  createAttribute(data: AttributeCreateInput!): Attribute!
  updateAttribute(data: AttributeUpdateInput!, where: AttributeWhereUniqueInput!): Attribute
  updateManyAttributes(data: AttributeUpdateManyMutationInput!, where: AttributeWhereInput): BatchPayload!
  upsertAttribute(where: AttributeWhereUniqueInput!, create: AttributeCreateInput!, update: AttributeUpdateInput!): Attribute!
  deleteAttribute(where: AttributeWhereUniqueInput!): Attribute
  deleteManyAttributes(where: AttributeWhereInput): BatchPayload!
  createEmail(data: EmailCreateInput!): Email!
  updateEmail(data: EmailUpdateInput!, where: EmailWhereUniqueInput!): Email
  updateManyEmails(data: EmailUpdateManyMutationInput!, where: EmailWhereInput): BatchPayload!
  upsertEmail(where: EmailWhereUniqueInput!, create: EmailCreateInput!, update: EmailUpdateInput!): Email!
  deleteEmail(where: EmailWhereUniqueInput!): Email
  deleteManyEmails(where: EmailWhereInput): BatchPayload!
  createFemale(data: FemaleCreateInput!): Female!
  updateFemale(data: FemaleUpdateInput!, where: FemaleWhereUniqueInput!): Female
  upsertFemale(where: FemaleWhereUniqueInput!, create: FemaleCreateInput!, update: FemaleUpdateInput!): Female!
  deleteFemale(where: FemaleWhereUniqueInput!): Female
  deleteManyFemales(where: FemaleWhereInput): BatchPayload!
  createIdentifiers(data: IdentifiersCreateInput!): Identifiers!
  updateIdentifiers(data: IdentifiersUpdateInput!, where: IdentifiersWhereUniqueInput!): Identifiers
  upsertIdentifiers(where: IdentifiersWhereUniqueInput!, create: IdentifiersCreateInput!, update: IdentifiersUpdateInput!): Identifiers!
  deleteIdentifiers(where: IdentifiersWhereUniqueInput!): Identifiers
  deleteManyIdentifierses(where: IdentifiersWhereInput): BatchPayload!
  createMale(data: MaleCreateInput!): Male!
  updateMale(data: MaleUpdateInput!, where: MaleWhereUniqueInput!): Male
  upsertMale(where: MaleWhereUniqueInput!, create: MaleCreateInput!, update: MaleUpdateInput!): Male!
  deleteMale(where: MaleWhereUniqueInput!): Male
  deleteManyMales(where: MaleWhereInput): BatchPayload!
  createPhoneNumber(data: PhoneNumberCreateInput!): PhoneNumber!
  updatePhoneNumber(data: PhoneNumberUpdateInput!, where: PhoneNumberWhereUniqueInput!): PhoneNumber
  updateManyPhoneNumbers(data: PhoneNumberUpdateManyMutationInput!, where: PhoneNumberWhereInput): BatchPayload!
  upsertPhoneNumber(where: PhoneNumberWhereUniqueInput!, create: PhoneNumberCreateInput!, update: PhoneNumberUpdateInput!): PhoneNumber!
  deletePhoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  deleteManyPhoneNumbers(where: PhoneNumberWhereInput): BatchPayload!
  createTaxId(data: TaxIdCreateInput!): TaxId!
  updateTaxId(data: TaxIdUpdateInput!, where: TaxIdWhereUniqueInput!): TaxId
  upsertTaxId(where: TaxIdWhereUniqueInput!, create: TaxIdCreateInput!, update: TaxIdUpdateInput!): TaxId!
  deleteTaxId(where: TaxIdWhereUniqueInput!): TaxId
  deleteManyTaxIds(where: TaxIdWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PhoneNumber {
  id: ID!
  value: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  attribute(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type PhoneNumberConnection {
  pageInfo: PageInfo!
  edges: [PhoneNumberEdge]!
  aggregate: AggregatePhoneNumber!
}

input PhoneNumberCreateInput {
  id: ID
  value: Int
  owner: UserCreateOneWithoutPhone_numberInput!
  attribute: AttributeCreateManyWithoutPhone_numberInput
}

input PhoneNumberCreateManyInput {
  create: [PhoneNumberCreateInput!]
  connect: [PhoneNumberWhereUniqueInput!]
}

input PhoneNumberCreateManyWithoutAttributeInput {
  create: [PhoneNumberCreateWithoutAttributeInput!]
  connect: [PhoneNumberWhereUniqueInput!]
}

input PhoneNumberCreateManyWithoutOwnerInput {
  create: [PhoneNumberCreateWithoutOwnerInput!]
  connect: [PhoneNumberWhereUniqueInput!]
}

input PhoneNumberCreateWithoutAttributeInput {
  id: ID
  value: Int
  owner: UserCreateOneWithoutPhone_numberInput!
}

input PhoneNumberCreateWithoutOwnerInput {
  id: ID
  value: Int
  attribute: AttributeCreateManyWithoutPhone_numberInput
}

type PhoneNumberEdge {
  node: PhoneNumber!
  cursor: String!
}

enum PhoneNumberOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhoneNumberPreviousValues {
  id: ID!
  value: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhoneNumberScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhoneNumberScalarWhereInput!]
  OR: [PhoneNumberScalarWhereInput!]
  NOT: [PhoneNumberScalarWhereInput!]
}

type PhoneNumberSubscriptionPayload {
  mutation: MutationType!
  node: PhoneNumber
  updatedFields: [String!]
  previousValues: PhoneNumberPreviousValues
}

input PhoneNumberSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhoneNumberWhereInput
  AND: [PhoneNumberSubscriptionWhereInput!]
  OR: [PhoneNumberSubscriptionWhereInput!]
  NOT: [PhoneNumberSubscriptionWhereInput!]
}

input PhoneNumberUpdateDataInput {
  value: Int
  owner: UserUpdateOneRequiredWithoutPhone_numberInput
  attribute: AttributeUpdateManyWithoutPhone_numberInput
}

input PhoneNumberUpdateInput {
  value: Int
  owner: UserUpdateOneRequiredWithoutPhone_numberInput
  attribute: AttributeUpdateManyWithoutPhone_numberInput
}

input PhoneNumberUpdateManyDataInput {
  value: Int
}

input PhoneNumberUpdateManyInput {
  create: [PhoneNumberCreateInput!]
  update: [PhoneNumberUpdateWithWhereUniqueNestedInput!]
  upsert: [PhoneNumberUpsertWithWhereUniqueNestedInput!]
  delete: [PhoneNumberWhereUniqueInput!]
  connect: [PhoneNumberWhereUniqueInput!]
  set: [PhoneNumberWhereUniqueInput!]
  disconnect: [PhoneNumberWhereUniqueInput!]
  deleteMany: [PhoneNumberScalarWhereInput!]
  updateMany: [PhoneNumberUpdateManyWithWhereNestedInput!]
}

input PhoneNumberUpdateManyMutationInput {
  value: Int
}

input PhoneNumberUpdateManyWithoutAttributeInput {
  create: [PhoneNumberCreateWithoutAttributeInput!]
  delete: [PhoneNumberWhereUniqueInput!]
  connect: [PhoneNumberWhereUniqueInput!]
  set: [PhoneNumberWhereUniqueInput!]
  disconnect: [PhoneNumberWhereUniqueInput!]
  update: [PhoneNumberUpdateWithWhereUniqueWithoutAttributeInput!]
  upsert: [PhoneNumberUpsertWithWhereUniqueWithoutAttributeInput!]
  deleteMany: [PhoneNumberScalarWhereInput!]
  updateMany: [PhoneNumberUpdateManyWithWhereNestedInput!]
}

input PhoneNumberUpdateManyWithoutOwnerInput {
  create: [PhoneNumberCreateWithoutOwnerInput!]
  delete: [PhoneNumberWhereUniqueInput!]
  connect: [PhoneNumberWhereUniqueInput!]
  set: [PhoneNumberWhereUniqueInput!]
  disconnect: [PhoneNumberWhereUniqueInput!]
  update: [PhoneNumberUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PhoneNumberUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [PhoneNumberScalarWhereInput!]
  updateMany: [PhoneNumberUpdateManyWithWhereNestedInput!]
}

input PhoneNumberUpdateManyWithWhereNestedInput {
  where: PhoneNumberScalarWhereInput!
  data: PhoneNumberUpdateManyDataInput!
}

input PhoneNumberUpdateWithoutAttributeDataInput {
  value: Int
  owner: UserUpdateOneRequiredWithoutPhone_numberInput
}

input PhoneNumberUpdateWithoutOwnerDataInput {
  value: Int
  attribute: AttributeUpdateManyWithoutPhone_numberInput
}

input PhoneNumberUpdateWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput!
  data: PhoneNumberUpdateDataInput!
}

input PhoneNumberUpdateWithWhereUniqueWithoutAttributeInput {
  where: PhoneNumberWhereUniqueInput!
  data: PhoneNumberUpdateWithoutAttributeDataInput!
}

input PhoneNumberUpdateWithWhereUniqueWithoutOwnerInput {
  where: PhoneNumberWhereUniqueInput!
  data: PhoneNumberUpdateWithoutOwnerDataInput!
}

input PhoneNumberUpsertWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput!
  update: PhoneNumberUpdateDataInput!
  create: PhoneNumberCreateInput!
}

input PhoneNumberUpsertWithWhereUniqueWithoutAttributeInput {
  where: PhoneNumberWhereUniqueInput!
  update: PhoneNumberUpdateWithoutAttributeDataInput!
  create: PhoneNumberCreateWithoutAttributeInput!
}

input PhoneNumberUpsertWithWhereUniqueWithoutOwnerInput {
  where: PhoneNumberWhereUniqueInput!
  update: PhoneNumberUpdateWithoutOwnerDataInput!
  create: PhoneNumberCreateWithoutOwnerInput!
}

input PhoneNumberWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  attribute_every: AttributeWhereInput
  attribute_some: AttributeWhereInput
  attribute_none: AttributeWhereInput
  AND: [PhoneNumberWhereInput!]
  OR: [PhoneNumberWhereInput!]
  NOT: [PhoneNumberWhereInput!]
}

input PhoneNumberWhereUniqueInput {
  id: ID
}

type Query {
  attribute(where: AttributeWhereUniqueInput!): Attribute
  attributes(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute]!
  attributesConnection(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttributeConnection!
  email(where: EmailWhereUniqueInput!): Email
  emails(where: EmailWhereInput, orderBy: EmailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Email]!
  emailsConnection(where: EmailWhereInput, orderBy: EmailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmailConnection!
  female(where: FemaleWhereUniqueInput!): Female
  females(where: FemaleWhereInput, orderBy: FemaleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Female]!
  femalesConnection(where: FemaleWhereInput, orderBy: FemaleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FemaleConnection!
  identifiers(where: IdentifiersWhereUniqueInput!): Identifiers
  identifierses(where: IdentifiersWhereInput, orderBy: IdentifiersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Identifiers]!
  identifiersesConnection(where: IdentifiersWhereInput, orderBy: IdentifiersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IdentifiersConnection!
  male(where: MaleWhereUniqueInput!): Male
  males(where: MaleWhereInput, orderBy: MaleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Male]!
  malesConnection(where: MaleWhereInput, orderBy: MaleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MaleConnection!
  phoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  phoneNumbers(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber]!
  phoneNumbersConnection(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhoneNumberConnection!
  taxId(where: TaxIdWhereUniqueInput!): TaxId
  taxIds(where: TaxIdWhereInput, orderBy: TaxIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TaxId]!
  taxIdsConnection(where: TaxIdWhereInput, orderBy: TaxIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaxIdConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  attribute(where: AttributeSubscriptionWhereInput): AttributeSubscriptionPayload
  email(where: EmailSubscriptionWhereInput): EmailSubscriptionPayload
  female(where: FemaleSubscriptionWhereInput): FemaleSubscriptionPayload
  identifiers(where: IdentifiersSubscriptionWhereInput): IdentifiersSubscriptionPayload
  male(where: MaleSubscriptionWhereInput): MaleSubscriptionPayload
  phoneNumber(where: PhoneNumberSubscriptionWhereInput): PhoneNumberSubscriptionPayload
  taxId(where: TaxIdSubscriptionWhereInput): TaxIdSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type TaxId {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  attribute(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type TaxIdConnection {
  pageInfo: PageInfo!
  edges: [TaxIdEdge]!
  aggregate: AggregateTaxId!
}

input TaxIdCreateInput {
  id: ID
  owner: UserCreateOneInput!
  attribute: AttributeCreateManyWithoutTax_idInput
}

input TaxIdCreateManyInput {
  create: [TaxIdCreateInput!]
  connect: [TaxIdWhereUniqueInput!]
}

input TaxIdCreateManyWithoutAttributeInput {
  create: [TaxIdCreateWithoutAttributeInput!]
  connect: [TaxIdWhereUniqueInput!]
}

input TaxIdCreateWithoutAttributeInput {
  id: ID
  owner: UserCreateOneInput!
}

type TaxIdEdge {
  node: TaxId!
  cursor: String!
}

enum TaxIdOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TaxIdPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TaxIdScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TaxIdScalarWhereInput!]
  OR: [TaxIdScalarWhereInput!]
  NOT: [TaxIdScalarWhereInput!]
}

type TaxIdSubscriptionPayload {
  mutation: MutationType!
  node: TaxId
  updatedFields: [String!]
  previousValues: TaxIdPreviousValues
}

input TaxIdSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TaxIdWhereInput
  AND: [TaxIdSubscriptionWhereInput!]
  OR: [TaxIdSubscriptionWhereInput!]
  NOT: [TaxIdSubscriptionWhereInput!]
}

input TaxIdUpdateDataInput {
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyWithoutTax_idInput
}

input TaxIdUpdateInput {
  owner: UserUpdateOneRequiredInput
  attribute: AttributeUpdateManyWithoutTax_idInput
}

input TaxIdUpdateManyInput {
  create: [TaxIdCreateInput!]
  update: [TaxIdUpdateWithWhereUniqueNestedInput!]
  upsert: [TaxIdUpsertWithWhereUniqueNestedInput!]
  delete: [TaxIdWhereUniqueInput!]
  connect: [TaxIdWhereUniqueInput!]
  set: [TaxIdWhereUniqueInput!]
  disconnect: [TaxIdWhereUniqueInput!]
  deleteMany: [TaxIdScalarWhereInput!]
}

input TaxIdUpdateManyWithoutAttributeInput {
  create: [TaxIdCreateWithoutAttributeInput!]
  delete: [TaxIdWhereUniqueInput!]
  connect: [TaxIdWhereUniqueInput!]
  set: [TaxIdWhereUniqueInput!]
  disconnect: [TaxIdWhereUniqueInput!]
  update: [TaxIdUpdateWithWhereUniqueWithoutAttributeInput!]
  upsert: [TaxIdUpsertWithWhereUniqueWithoutAttributeInput!]
  deleteMany: [TaxIdScalarWhereInput!]
}

input TaxIdUpdateWithoutAttributeDataInput {
  owner: UserUpdateOneRequiredInput
}

input TaxIdUpdateWithWhereUniqueNestedInput {
  where: TaxIdWhereUniqueInput!
  data: TaxIdUpdateDataInput!
}

input TaxIdUpdateWithWhereUniqueWithoutAttributeInput {
  where: TaxIdWhereUniqueInput!
  data: TaxIdUpdateWithoutAttributeDataInput!
}

input TaxIdUpsertWithWhereUniqueNestedInput {
  where: TaxIdWhereUniqueInput!
  update: TaxIdUpdateDataInput!
  create: TaxIdCreateInput!
}

input TaxIdUpsertWithWhereUniqueWithoutAttributeInput {
  where: TaxIdWhereUniqueInput!
  update: TaxIdUpdateWithoutAttributeDataInput!
  create: TaxIdCreateWithoutAttributeInput!
}

input TaxIdWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  attribute_every: AttributeWhereInput
  attribute_some: AttributeWhereInput
  attribute_none: AttributeWhereInput
  AND: [TaxIdWhereInput!]
  OR: [TaxIdWhereInput!]
  NOT: [TaxIdWhereInput!]
}

input TaxIdWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  phone_number(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber!]
  role: AuthLevel
  gender: Gender!
  identifiers: Identifiers!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  phone_number: PhoneNumberCreateManyWithoutOwnerInput
  role: AuthLevel
  gender: Gender!
  identifiers: IdentifiersCreateOneInput!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPhone_numberInput {
  create: UserCreateWithoutPhone_numberInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPhone_numberInput {
  id: ID
  email: String!
  role: AuthLevel
  gender: Gender!
  identifiers: IdentifiersCreateOneInput!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  role_ASC
  role_DESC
  gender_ASC
  gender_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  role: AuthLevel
  gender: Gender!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  phone_number: PhoneNumberUpdateManyWithoutOwnerInput
  role: AuthLevel
  gender: Gender
  identifiers: IdentifiersUpdateOneRequiredInput
}

input UserUpdateInput {
  email: String
  phone_number: PhoneNumberUpdateManyWithoutOwnerInput
  role: AuthLevel
  gender: Gender
  identifiers: IdentifiersUpdateOneRequiredInput
}

input UserUpdateManyMutationInput {
  email: String
  role: AuthLevel
  gender: Gender
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPhone_numberInput {
  create: UserCreateWithoutPhone_numberInput
  update: UserUpdateWithoutPhone_numberDataInput
  upsert: UserUpsertWithoutPhone_numberInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutPhone_numberDataInput {
  email: String
  role: AuthLevel
  gender: Gender
  identifiers: IdentifiersUpdateOneRequiredInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutPhone_numberInput {
  update: UserUpdateWithoutPhone_numberDataInput!
  create: UserCreateWithoutPhone_numberInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone_number_every: PhoneNumberWhereInput
  phone_number_some: PhoneNumberWhereInput
  phone_number_none: PhoneNumberWhereInput
  role: AuthLevel
  role_not: AuthLevel
  role_in: [AuthLevel!]
  role_not_in: [AuthLevel!]
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  identifiers: IdentifiersWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`